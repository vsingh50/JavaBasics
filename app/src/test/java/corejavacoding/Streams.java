/*
 * This source file was generated by the Gradle 'init' task
 */
package corejavacoding;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.BinaryOperator;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.UnaryOperator;
import java.util.stream.Collectors;
import java.util.stream.Stream;



public class Streams {

    String names;

    public Streams(String names) {
        this.names = names;
    }

    // lambda expression --> just like a method, but having no name, no access
    // modifier, no return type
    /*
     * pubilc static void run(){
     * System.out.println("running method");
     * }
     * so lambda expression of above function will be
     * () -> {
     * System.out.println("running method");
     * }
     * name, access modifier, return are removed and a -> is introduced.
     * lambda expression are used to implement functional interfaces
     * functinoal interfaces -- > wo interface jisme ek hi abstract method hota h.
     */

    /*
     * Predicate -- Functional INterface (boolean valued function)
     */

    public static void main(String[] args) {

        /*
         * Predicate -- Functional INterface (boolean valued function)
         * agar aapko kuch check krna h to predicate ka use kre
         * predicate ek condition hold krta h
         * ek condition ko hum variable me store kr skte h predicate se
         * 
         */

        Predicate<Integer> isEven = x -> x % 2 == 0;
        Predicate<Integer> isOdd = x -> x % 2 != 0;
        String name = "Bakkshit";
        Predicate<String> isWordStartsWithA = x -> x.toLowerCase().startsWith("a");
        Predicate<String> isWordEndsWithE = x -> x.toLowerCase().endsWith("e");
        System.out.println(isEven.test(4)); // true;
        System.out.println(isOdd.test(7)); // true;
        System.out.println(isWordStartsWithA.test(name)); // false;
        System.out.println(isWordStartsWithA.test("Apple")); // true;
        System.out.println(isWordStartsWithA.test("Banana")); // false;
        Predicate<String> and = isWordStartsWithA.and(isWordEndsWithE);
        System.out.println(and.test("apple")); // true;
        System.out.println(and.test("adam")); // false;
        System.out.println(and.test("cat")); // false;
        System.out.println(and.test("anie")); // true;

        // Function
        /*
         * Function is also a functional interface having only one abstarct method
         * apply()
         * predicate was holding condition but function will do some work for us
         * it means it will take few things then according to our ask it will return
         * something
         */

        Function<Integer, Integer> doubleIt = x -> 2 * x;
        Function<Integer, Integer> tripleIt = x -> 3 * x;
        Function<Integer, Integer> doublethentriple = doubleIt.andThen(tripleIt);
        System.out.println(doubleIt.apply(4));
        System.out.println(doublethentriple.apply(5));

        Function<Integer, Integer> identity = Function.identity();
        /*
         * identity is a default method of funtion functional interface
         * it returns the same what it takes as input
         */
        System.out.println(identity.apply(5)); // 5

        /*
         * Consumer -- it consumes something, does not do anythin, it will take the
         * given
         */

        Consumer<String> printingString = x -> System.out.println(x);
        // above consumer will take string input and just print it in console as we have
        // defined it to the same
        printingString.accept("Hello World!"); // Hello World!
        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
        Consumer<List<Integer>> print = x -> {
            for (int i : x) {
                System.out.print(i + " ");
            }
        };

        // above consumer is taking input as List of integer and print all the elements
        // of the given list
        print.accept(list); // 1 2 3 4 5

        /*
         * Supplier -- it doesn't take anything rather it just returns what is feeded
         * into it
         */

        Supplier<String> helloWorldPrinting = () -> "Hello World!!!";
        System.out.println(helloWorldPrinting.get()); // it will print hello world

        // combined example
        Predicate<Integer> predicate = x -> x % 2 == 0;
        Function<Integer, Integer> function = x -> x * x;
        Consumer<Integer> consumer = x -> System.out.println(x);
        Supplier<Integer> supplier = () -> 100;

        if (predicate.test(supplier.get())) {
            consumer.accept(function.apply(supplier.get()));
        }

        // BiPredicate //BiFunction //BiConsumer

        BiPredicate<Integer, Integer> biPredicate = (x, y) -> (x + y) % 2 == 0;
        BiFunction<Integer, Integer, Integer> biFunction = (x, y) -> (x + y);
        BiConsumer<String, String> biConsumer = (x, y) -> {
            System.out.println(x);
            System.out.println(y);
        };

        System.out.println(biPredicate.test(3, 9)); // true;
        System.out.println(biFunction.apply(3, 9)); // 12;
        biConsumer.accept("Three", "Nine");

        /*
         * Unary Operator ---> kaam karega Funtion ka
         * Binary Operator ---> kaame karega BiFunction ka
         */

        UnaryOperator<Integer> uniOperator = x -> x * x;
        BinaryOperator<Integer> binaryOperator = (x, y) -> (x + y);

        System.out.println(uniOperator.apply(9)); // 81;
        System.out.println(binaryOperator.apply(10, 20)); // 30;

        // Method Reference
        /*
         * Using method reference we can use method without invoking it
         * we will use method reference in place of lambda expression
         */

        List<String> list2 = Arrays.asList("Ram", "Shyam", "Radha", "Rani");
        list2.forEach(x -> System.out.println(x)); // we are using lambda expression in the consumer
        list2.forEach(System.out::println); // here lambda expression is replaced with Method reference

        // Constructor Reference
        List<String> nameList = Arrays.asList("Groww", "Zerodha", "Whatsapp", "Instagram");
        List<App> appNames = nameList.stream()
                // .map(x -> new App(x)) // we have converted the List of name to app Names
                // using constructor refrence
                .map(App::new)
                .collect(Collectors.toList());

        /*
         * Stream
         * Stream is a feature of Java 8
         * using which we can process collections like list map etc in a functional and
         * declarative manner
         * Stream helps in data processing easily in a funational manner
         * Stream is a sequence of elements which supports functional and declarative
         * programming
         */

        /*
         * how to use stream
         * source ---> operations --> intermediate operations --> terminate operations
         */

        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
        // lets have a problem to count the even numbers from the above list
        /*
         * traditionally
         * int count = 0;
         * for(int i : numbers){
         * if(i%2==0){
         * count++
         * }
         * }
         * 
         * now learn using streams ---
         */
        long evenNumbers = numbers.stream()
                .filter(x -> x % 2 == 0)
                .count();
        System.out.println(evenNumbers);

        /*
         * using streams we did it in single statement.. this is the beauty of streams
         */

        /*
         * Creating Streams
         * 1. using collections --> use .stream()
         * 2. from Arrays
         */
        // 2. from Arrays
        String[] array = { "a,", "b", "c" };
        Stream<String> streamOfArray = Arrays.stream(array);

        // 3. Using StreamOf
        Stream<String> usingStreamOf = Stream.of("A", "B", "C");

        // 4. Infinte Stream
        Stream<Integer> streamUsingGenerate = Stream.generate(() -> +1).limit(100);
        List<Integer> streamUsingIterate = Stream.iterate(1, x -> x + 1).limit(100).collect(Collectors.toList()); // 1,2,3,4,5

        /*
         * Intermediate Operations
         * intermediate operations converts a stream into new stream
         * THEY WON'T EXECUTE UNTILL THE TERMINAL OPERATIONS ARE EXECUTED.
         */

        // 1. Filter
        List<String> namesss = Arrays.asList("Ram", "Radha", "Madhav", "Four", "Five", "Seven"); // source
        System.out.println(namesss.stream()
                .filter(x -> x.toLowerCase().startsWith("r")) // intermediate operation
                .count()); // terminal operaion

        // 2. Map
        // Printing the names whose length is odd and then we are lowering the first
        // character of each word
        List<String> listOfNames = namesss.stream()
                .filter(x -> x.length() % 2 != 0)
                .map(x -> x.substring(0, 1).toLowerCase() + x.substring(1))
                .collect(Collectors.toList());

        listOfNames.forEach(System.out::println); // Method Reference

        // Example -
        // Sorting and squaring the numbers of a list
        List<Integer> numbersList = Arrays.asList(5, 3, 6, 4, 9, 1);
        numbersList.stream()
                .map(x -> x * x)
                .sorted()
                .forEach(System.out::println);

        // Example -
        // Summing values
        System.out.println(numbersList.stream().reduce(Integer::sum).get());

        // Example -
        // Count the occurences of specific character

        String string = "hello world";
        long countOfChar = string.chars().filter(x -> x == 'l').count(); // counting for occurences of 'l'
        System.out.println(countOfChar);

        // 3. Sorted
        List<Integer> unsortedList = Arrays.asList(4, 6, 3, 2, 7, 3, 0, 2, 2);
        List<Integer> sortedList = unsortedList.stream().sorted().collect(Collectors.toList());

        // // 4. distinct
        long countOfDIstinct = unsortedList.stream().filter(x -> x % 2 == 0).count();

        Stream<Integer> streamInfinte = Stream.generate(() -> 1);

        // // 5. limit
        streamInfinte.limit(100);

        // //6. skip
        // streamInfinte.skip(10);

        /*
         * Terminal Operations
         * Only one terminal operation can be performed per stream because terminal
         * operations consume the stream. However, before the terminal operation, you
         * can chain multiple intermediate operations (like filter, map, etc.) to
         * process the stream.
         * 
         * If you try to invoke multiple terminal operations on the same stream, you'll
         * encounter an IllegalStateException, as the stream is already consumed by the
         * first terminal operation.
         */

        // 1. Collect   -> Collecting into a List:
        List<String> strings = Arrays.asList("One", "Two", "Three", "Four", "Five", "Six");
        List<String> result = strings.stream()
                             .filter(x -> x.length() % 2 != 0)
                             .map(String::toLowerCase)
                             .collect(Collectors.toList());

        // 2. forEach --- Iterating with forEach (without collecting):
         strings.stream()
        .filter(x -> x.length() % 2 != 0)
        .map(String::toLowerCase)
        .forEach(System.out::println);


        // 3. reduce -- combine elments to produce single result
        System.out.println(numbersList.stream().reduce(Integer::sum).get());


        // 4. count
        unsortedList.stream().filter(x -> x % 2 == 0).count();

        // 5. anyMatch, allMatch, noneMatch


        // 6. findFirst, findAny
        Optional<String> firstOddLengthString = strings.stream()
                                               .filter(x -> x.length() % 2 != 0)
                                               .findFirst();
        
        System.out.println(firstOddLengthString.get());

    }
}